## 1. extends ts 类型系统的地基

### 一、extends 作为「泛型约束」（最直观）

```
// 示例：
function getLength<T extends { length: number }>(arg: T) {
  return arg.length
}

// 含义
T 必须是一个「拥有 length 属性的类型」

// 合法
getLength('abc')
getLength([1, 2, 3])
```

### 二、extends 作为「类型 / 接口继承」（结构扩展） 

```
示例：
interface Animal {
  name: string
}

interface Dog extends Animal {
  bark(): void
}

含义：Dog 必须至少拥有 Animal 的所有结构

类型别名中：
type A = { a: number }
type B = A & { b: number }
和 interface extends 等价
```

### 三、extends 在条件类型中（⚠️核心重点） 

#### 1.基本语义

> A extends B ? X : Y

不是继承！ 而是A 能否赋值给 B？ 

```
示例：
type T1 = string extends string | number ? true : false
// true

type T2 = number extends string ? true : false
// false
```

>type ElementType<T> = T extends Array<infer U> ? U : T; 
>
>// 这里定义的 ElementType 就是一个泛型工具类型（utility type / 类型工具），而不是一个具体的、固定的类型。 
>
>- Partial<T>：把 T 的所有属性变可选。
>- Required<T>：把 T 的所有可选属性变必选。
>- Readonly<T>：把 T 变只读。
>- ReturnType<T>：提取函数 T 的返回类型。
>- Awaited<T>：递归解包 Promise。

#### 2. 赋值关系≠相等关系

```
type A = { a: number }
type B = { a: number; b: number }

A extends B // ❌ false
B extends A // ✅ true

// 集能赋值给父集
```

#### 3.联合类型的「分发」行为（极易踩坑） 

```
type ToArray<T> = T extends any ? T[] : never

type R = ToArray<string | number>
// string[] | number[]

等价于 ToArray<string> | ToArray<number>

// 如何阻止分发：
type NoDistribute<T> = [T] extends [any] ? T[] : never
```

### 四、extends + infer：模式匹配（最底层能力） 

这是 **extends 最强的形态** 

```
type ElementType<T> = T extends Array<infer U> ? U : T
```

把 T 当作一个整体，尝试套进 Array<某种结构> 这个“模板” 

>T = number[]
>→ Array<infer U>
>→ U = number

#### 1.infer 到底在干嘛？（不是声明类型）

- 实际上是：“当类型结构匹配成功时，把某一部分结构命名为 U”

#### 2.Array<infer U> 是什么？

- 我不关心数组里是什么类型,但如果你是数组，我要把元素类型存到 U 里
- infer U = 临时声明一个类型变量 U

#### 3.type A = (number[] | string) extends Array<infer U> ? U : T

等价于：

```
(number[] extends Array<infer U> ? U : number[]) |
(string extends Array<infer U> ? U : string)
```

#### 4.提取 Promise 返回值的类型 

```
type UnpackPromise<T> = T extends Promise<infer R> ? R : T; 
type Result = UnpackPromise<Promise<string>>; // Result 是 string 
```

### 五、extends 的「4 种角色」对照表，一句总结 

| 场景                    | extends 在做什么      |
| ----------------------- | --------------------- |
| `<T extends X>`         | **约束 T 的可选范围** |
| `interface B extends A` | **结构合并 / 扩展**   |
| `T extends X ? A : B`   | **类型判断（if）**    |
| `T extends X<infer U>`  | **结构匹配 + 解构**   |

`TypeScript 中的 extends，本质只有一件事：  判断“一个类型是否可以被当作另一个类型使用”  只是根据上下文不同，表现为约束、扩展、判断或匹配。 `

```
type MyReturnType<T> = T extends (...any: any[]) => inter R ? R : never; 
```



## 2. 基础查询与转换 ——keyof  索引类型查询 , typeof   类型查询  

### 1.获取一个对象类型的所有键（Key），返回联合类型。 

### 2.在类型上下文中获取一个**变量或属性**的类型。 

```
const Config = {
  port: 8080,
  host: "localhost"
};

// 1. 获取 Config 对象的类型
type ConfigType = typeof Config; // { port: number, host: string }

// 2. 获取 ConfigType 的所有键
type ConfigKeys = keyof ConfigType; // "port" | "host"
```

## 3.基础查询与转换 ——T[K]  索引访问  

### 1.获取类型 `T` 中特定键 `K` 的类型。 

## 4. 逻辑组合  ——&  交叉类型 

### 1.将多个类型合并为一个类型（必须同时满足）。 

## 5.逻辑组合  ——| 联合类型  

### 1. 表示类型可以是多个中的任意一个。 

## 6.映射操作 ——in

### 1.遍历联合类型（通常与 `keyof` 配合） 

## 7.只读修饰 ——readonly 

### 1.将属性标记为不可改写 

## 8.可选修饰  ——? 

### 1.将属性标记为可选。 

## 9.操作符执行顺序

TypeScript 并没有官方给出的严格优先级表，但我们可以根据逻辑嵌套的习惯来归纳。通常情况下，**从左到右、从内到外**，具体遵循以下规律：

1. **括号 ()**：拥有最高优先级，用于改变默认顺序
2. **后缀操作符**：`T[K]`（索引访问）优先级极高
3. **前缀操作符**：`keyof`, `typeof`, `readonly` 等
4. **extends 约束**：在泛型定义中的约束
5. **交叉类型 &**：优于联合类型 `|`
6. **联合类型 |**
7. **条件类型 T extends U ? X : Y**：通常最后计算

> **注意：** `&` 的优先级高于 `|`，这类似于数学中的乘法优于加法。 `type T = A & B | C & D` 会被解析为 `(A & B) | (C & D)`

```
type HighLevel<T> = {
  readonly [P in keyof T]-?: T[P]; 
};
// 1. keyof T: 获取所有键
// 2. in: 遍历这些键
// 3. -?: 去掉可选修饰符
// 4. readonly: 加上只读修饰
// 5. T[P]: 索引访问获取原类型
```

## 10.TypeScript 内置的工具类型（Utility Types） 

### 1.属性转换类 

| **工具类型**    | **作用**                        | **核心原理**                    |
| --------------- | ------------------------------- | ------------------------------- |
| **Partial<T>**  | 将 `T` 的所有属性变为**可选**。 | `[P in keyof T]?: T[P]`         |
| **Required<T>** | 将 `T` 的所有属性变为**必选**。 | `[P in keyof T]-?: T[P]`        |
| **Readonly<T>** | 将 `T` 的所有属性变为**只读**。 | `readonly [P in keyof T]: T[P]` |

### 2.结构提取类 

| **工具类型**     | **作用**                               | **示例**                    |
| ---------------- | -------------------------------------- | --------------------------- |
| **Pick<T, K>**   | 从 `T` 中提取一组键为 `K` 的属性。     | `Pick<User, 'id' | 'name'>` |
| **Omit<T, K>**   | 从 `T` 中剔除键为 `K` 的属性。         | `Omit<User, 'password'>`    |
| **Record<K, T>** | 构造一个对象类型，键为 `K`，值为 `T`。 | `Record<string, number>`    |





- 结果 A = number | string
